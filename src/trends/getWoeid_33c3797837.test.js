// ********RoostGPT********
// Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=getWoeid_32ca391499



// ********RoostGPT********
const request = require('superagent');
const { getWoeid } = require('./trends');

describe('getWoeid', () => {
  const yahooURI = 'https://query.yahooapis.com/v1/public/yql';

  beforeEach(() => {
    jest.restoreAllMocks();
  });

  test('should successfully get the WOEID for a given place', async () => {
    const place = 'San Francisco';
    const mockResponse = {
      body: {
        query: {
          results: {
            place: {
              woeid: '2487956'
            }
          }
        }
      }
    };

    jest.spyOn(request, 'get').mockResolvedValue(mockResponse);
    const response = await getWoeid(place);
    expect(request.get).toHaveBeenCalledWith(yahooURI);
    expect(request.get).toHaveBeenLastCalledWith(expect.objectContaining({
      query: {
        q: `select woeid from geo.places where text="${place}" limit 1`,
        diagnostics: 'false',
        format: 'json'
      }
    }));
    expect(response).toEqual(mockResponse);
  });

  test('should handle the case when the place is not found', async () => {
    const place = 'Nowhere';
    const mockResponse = {
      body: {
        query: {
          results: null
        }
      }
    };

    jest.spyOn(request, 'get').mockResolvedValue(mockResponse);
    const response = await getWoeid(place);
    expect(request.get).toHaveBeenCalledWith(yahooURI);
    expect(response).toEqual(mockResponse);
  });

  test('should handle errors from the request', async () => {
    const place = 'San Francisco';
    const error = new Error('Bad Request');
    jest.spyOn(request, 'get').mockRejectedValue(error);

    await expect(getWoeid(place)).rejects.toThrow('Bad Request');
    expect(request.get).toHaveBeenCalledWith(yahooURI);
  });
});
